---
title: "Carry column metadata in pivot_longer"
author: "Nick Carruthers"
date: "15/06/2020"
output: html_document
knit: (function(input_file, encoding) {
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), 'index.html'))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Background:
Lots of bioinformatics workflows require both **long** and **wide** data.  **Wide** data is the most common output format generated by proteomics search engines: each row is a protein and columns are samples.  Each cell contains a quantitative value like abundance.  **Long** data will have a single column for the quantitative values and two columns to indicate row and sample. To me the advantages of using **long** data are (1) that it provides a unified format for any required data manipulations and summarizations and (2) that it is the required input format for the ggplot system.  In R [the tidyverse](https://www.tidyverse.org/) provides the tools to go from one to another.

#### The Problem:  
Typically samples (columns) will have associated metadata like treatments and indicators of groups or replicates.  Any metadata that corresponds to rows can be easily added to the data.frame to be pivoted (eg. with cbind).  But if there are both row and column metadata how the latter have to be added manually.  

#### The Solution:
There are a couple of options.  My favorite way is to convert a key column to an ordered factor and then "map" the metadata to it.  I see the ordered factor as a benefit as it is often required to control plot order in ggplot.  
 

```{r include = FALSE}
library(tidyverse)
```

```{r}
head(relig_income)
```

#### First, create the metadata.  
This only applies to data with both row and column metadata.  I'll use the `relig_income` dataset as an example.  To make this a suitable example I will add a random column for religion class and group income levels into low, medium, high and unknown listed in a separate `data.frame`.  Note that this method relies on the column metadata being complete and accurate so check that table carefully!

```{r}
## Row metadata
set.seed(10)
relig_income$religionClass <- 
  sample(c("A", "B", "C"), nrow(relig_income), replace = TRUE)

## Column metadata
columnMetadata <- data.frame(
  income = c(colnames(relig_income)[
    grepl("0", colnames(relig_income))],
    "Don't know/refused"),
  incomeGroup = c(rep("low", 3), rep("medium", 3), 
            rep("high", 3), "Don't know/refused"))
columnMetadata
```

#### Step 1: pivot_longer as usual

```{r}
relig_income %>%
  pivot_longer(-c(religion, religionClass), names_to = "income", values_to = "count")
```

#### Step 2:  convert key column to an ordered factor  
This has the added benefit that it controls the order of this column when plotting

```{r}
relig_income %>%
  pivot_longer(-c(religion, religionClass), names_to = "income", values_to = "count") %>%
  mutate(income = ordered(income, levels = columnMetadata$income))
```

#### Step 3:  Use the factor levels to map the new data  
```{r}
relig_income %>%
  pivot_longer(-c(religion, religionClass), names_to = "income", values_to = "count") %>%
  mutate(income = ordered(income, levels = columnMetadata$income)) %>%
  mutate(incomeClass = columnMetadata$incomeGroup[income])
```

Finally it's a good idea to make a look at the mapping to ensure it worked.  

```{r}
test <- relig_income %>%
  pivot_longer(-c(religion, religionClass), names_to = "income", values_to = "count") %>%
  mutate(income = ordered(income, levels = columnMetadata$income)) %>%
  mutate(incomeClass = columnMetadata$incomeGroup[income])

table(test$income, test$incomeClass)
```

#### The metadata columns are now available
We can plot the data summarized by our arbitrary grouping of religions and colored by our grouped income levels.

```{r fig.width = 8, fig.height = 8}
relig_income %>%
  pivot_longer(-c(religion, religionClass), names_to = "income", values_to = "count") %>%
  mutate(income = ordered(income, levels = columnMetadata$income)) %>%
  mutate(incomeClass = columnMetadata$incomeGroup[income]) %>%
  group_by(religionClass, income, incomeClass) %>%
  summarize(meanCount = mean(count)) %>%
  ggplot(aes(x = income, y = meanCount, fill = incomeClass)) +
  geom_col() +
  facet_wrap(vars(religionClass)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


```

